package baidu;

/**
 * 公司里面有1001个员工，现在要在公司里面找到最好的羽毛球选手，也就是第一名，每个人都必须参赛，问至少要比赛多少次才能够找到最好的羽毛球员工。
 */
public class WinnerTree {

	/**
	 * 赢者树（Winner Tree）思路：
	 * 
	 * <pre>
	 * 设员工的人数为N，f（N）最少需要的比赛次数，如果N为2的整数倍，可以很容易用数学归纳法证明f(N)=N-1。
	 * 如果N不是2的整数倍，设比N大的最小的是2的整数倍的整数为A（例如当N=1001时，A=1024）。那么两者的差别是，当N个员工比赛时，
	 * 第一轮需要有A-N个员工轮空。所以f(N)=f(A)-(A-N)=A-1-A+N=N-1。 综上，当N为大于0的整数时，以下结论总是成立： f(N)=N-1。
	 * 具体到该题,f(1001)=1000。 以下是一个验证程序。
	 * </pre>
	 */

	/**
	 * 程序的思路是：只要是偶数个员工，就比赛，如果是奇数个员工，就让1个员工留到下一轮去比赛。结果仍然是N-1次。
	 * 另一种思路,题目只要找出第一名，并没有其它限制，那么随意挑选两名员工进行比赛，败者淘汰，胜者继续和剩下的员工中的一名进行比赛，如此循环。同样，
	 * N名员工需要进行N-1次比赛来确定冠军。这个思路和选择排序或冒泡排序的思路是类似的。
	 */
	public static int f(int n) {
		if (n == 1)
			return 0;
		else
			return f(n / 2 + n % 2) + n / 2;
	}

	public static void main(String[] args) {
		int N = 1001;
		System.out.println(f(N));
	}
}
